var o=Object.defineProperty;var m=(x,B)=>{for(var z in B)o(x,z,{get:B[z],enumerable:!0,configurable:!0,set:(Z)=>B[z]=()=>Z})};var O=process.env.DEV_MODE==="true",i="debug",v="info",s="warn",w="error",n=(x)=>typeof x==="string"&&x.trim()!=="",r=(x)=>x?`#${x}`:"",t=(x)=>x.length?`.${Array.from(x).join(".")}`:"",u=(x)=>`<${x.localName}${r(x.id)}${t(x.classList)}>`,l=(x)=>n(x)?`"${x}"`:typeof x==="object"?JSON.stringify(x):x!=null?String(x):"undefined",N=(x,B,z="debug")=>{if(O||["error","warn"].includes(z))console[z](B,x);return x};var J=(x)=>typeof x==="function";var _=(x)=>(B)=>B instanceof x,U=(x)=>_(Error)(x),D=function(){return this};var M={};m(M,{of:()=>S,isMaybe:()=>E});var S=(x)=>x==null?H.of():E(x)?x:X.of(x),E=(x)=>X.isOk(x)||H.isNil(x);class H{static instance=new H;static of=()=>H.instance;static isNil=(x)=>x===H.instance;get=()=>{return}}var V=H.prototype;V.map=V.chain=V.filter=V.guard=V.catch=D;V.or=(x)=>S(x());V.match=function(x){return J(x.Nil)?x.Nil():this};class X{x;constructor(x){this.value=x}static of=(x)=>new X(x);static isOk=_(X);get(){return this.value}}var q=X.prototype;q.map=function(x){return new X(x(this.value))};q.chain=function(x){return x(this.value)};q.filter=q.guard=function(x){return x(this.value)?this:H.of()};q.or=q.catch=D;q.match=function(x){return J(x.Ok)?x.Ok(this.value):this};class K{x;constructor(x){this.error=x}static of=(x)=>new K(U(x)?x:new Error(String(x)));static isErr=_(K);get(){throw this.error}}var A=K.prototype;A.map=A.chain=D;A.filter=A.guard=()=>H.of();A.or=(x)=>S(x());A.catch=function(x){return x(this.error)};A.match=function(x){return J(x.Err)?x.Err(this.error):this};var j={};m(j,{unwrap:()=>e,of:()=>F,isResult:()=>k,fromAsync:()=>p,from:()=>g,flow:()=>a});var F=(x)=>x==null?H.of():k(x)?x:U(x)?K.of(x):X.of(x),g=(x,...B)=>{try{return F(x(...B))}catch(z){return K.of(z)}},p=async(x,...B)=>{try{return F(await x(...B))}catch(z){return K.of(z)}},k=(x)=>X.isOk(x)||H.isNil(x)||K.isErr(x),a=async(...x)=>{let B=J(x[0])?H.of():F(x.shift());for(let z of x){if(K.isErr(B))break;if(!J(z))return K.of(new TypeError("Expected a function in flow"));B=/^async\s+/.test(z.toString())?await p(async()=>z(B.get())):g(z,B.get())}return B},e=(x)=>K.isErr(x)?x.error:X.isOk(x)||H.isNil(x)?x.get():x;var P=()=>{let x=new Map,B=new Map,z,Z=(W,$)=>j.from(W).match({Err:(G)=>K.of(N(G,$,w))}),Y=()=>{z=null,x.forEach((W,$)=>W.forEach((G,T)=>Z(G($),`Effect ${T} on ${$?.localName||"unknown"} failed`))),x.clear(),B.forEach((W)=>Z(W,"Cleanup failed")),B.clear()},c=()=>{if(z)cancelAnimationFrame(z);z=requestAnimationFrame(Y)},f=(W)=>{if(!x.has(W))x.set(W,new Map);return x.get(W)},y=(W)=>($,G)=>{let T=!W.has($);if(W.set($,G),T)c()};return queueMicrotask(Y),{enqueue:(W,$,G)=>y(f(W))($,G),cleanup:y(B)}};var h=(x)=>J(x)&&/^async\s+/.test(x.toString()),d=_(Promise);class C{x;sinks=new Set;value=void 0;error=null;stale=!0;memo=!1;async=!1;constructor(x,B){this.fn=x;this.async=h(x),this.memo=B??this.async}static of(x,B){return new C(x,B)}static isComputed=(x)=>x instanceof C;get(){if(Q(this.sinks),!this.memo||this.stale)R(()=>{let x=(Y)=>{this.stale=Z!==null,this.value=Y,this.error=null},B=(Y)=>{this.stale=!0,this.error=Y},z=(Y)=>U(Y)?B(Y):x(Y),Z=j.unwrap(j.from(this.fn));d(Z)?Z.then((Y)=>z(j.unwrap(Y))).catch(B):z(Z)},()=>{if(this.stale=!0,this.memo)b(this.sinks)});if(this.error)throw this.error;return this.value}}var I,Q=(x)=>{if(I)x.add(I)},b=(x)=>x.forEach((B)=>B()),R=(x,B)=>{let z=I;I=B,x(),I=z};class L{x;sinks=new Set;constructor(x){this.value=x}static of(x){return new L(x)}static isState=(x)=>x instanceof L;get(){return Q(this.sinks),this.value}set(x){let B=J(x)?x(this.value):x;if(!Object.is(this.value,B))this.value=B,b(this.sinks)}}var{enqueue:xx,cleanup:Bx}=P(),zx=(x)=>{let B=()=>R(()=>M.of(x(xx)).guard(J).map((z)=>Bx(x,z)),B);B()};export{l as valueString,P as scheduler,N as log,J as isFunction,u as elementName,zx as effect,L as State,j as Result,X as Ok,H as Nil,M as Maybe,s as LOG_WARN,v as LOG_INFO,w as LOG_ERROR,i as LOG_DEBUG,K as Err,O as DEV_MODE,C as Computed};
