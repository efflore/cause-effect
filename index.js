var K=(y)=>typeof y==="function",M=(y)=>K(y)&&/^async\s+/.test(y.toString()),A=(y)=>(x)=>x instanceof y,G=A(Error),V=A(Promise);var Y="Computed",F={of:(y,x)=>{x=x??M(y);let B=new Set,W,q=null,z=!0,D=()=>{if(z=!0,x)I(B)},O=()=>{try{return y()}catch(k){return G(k)?k:new Error(`Error during reactive computation: ${k}`)}},P=(k)=>{z=!1,W=k,q=null},X=(k)=>{z=!0,q=k},Z=(k)=>G(k)?X(k):P(k),$={[Symbol.toStringTag]:Y,get:()=>{if(H(B),!x||z)J(()=>{let k=O();V(k)?k.then(Z).catch(X):Z(k)},D);if(G(q))throw q;return W},map:(k)=>F.of(()=>k($.get()))};return $},isComputed:(y)=>!!y&&typeof y==="object"&&y[Symbol.toStringTag]===Y};var L,N=!1,Q=new Set;var H=(y)=>{if(L)y.add(L)},I=(y)=>y.forEach((x)=>N?Q.add(x):x()),J=(y,x)=>{let B=L;L=x,y(),L=B},R=(y)=>{N=!0,y(),N=!1,Q.forEach((x)=>x()),Q.clear()};class j{y;watchers=new Set;constructor(y){this.value=y}static of(y){return new j(y)}static isState=A(j);get(){return H(this.watchers),this.value}set(y){let x=K(y)?y(this.value):y;if(Object.is(this.value,x))return;this.value=x,I(this.watchers)}map(y){return F.of(()=>y(this.get()))}}var U=(y)=>{let x=()=>J(()=>{try{y()}catch(B){console.error(B)}},x);x()};export{U as effect,R as batch,j as State,F as Computed};
