var T=(P)=>typeof P==="function",G=(P)=>T(P)&&/^async\s+/.test(P.toString()),H=(P)=>(I)=>I instanceof P,B=H(Error),J=H(Promise);class U{P;sinks=new Set;value=void 0;error=null;stale=!0;memo=!1;async=!1;constructor(P,I){this.fn=P;this.async=G(P),this.memo=I??this.async}static of(P,I){return new U(P,I)}static isComputed=(P)=>P instanceof U;get(){if(w(this.sinks),!this.memo||this.stale)z(()=>{let P=()=>{try{return this.fn()}catch(L){return B(L)?L:new Error(`Error during reactive computation: ${L}`)}},I=(L)=>{this.stale=q!==null,this.value=L,this.error=null},O=(L)=>{this.stale=!0,this.error=L},D=(L)=>B(L)?O(L):I(L),q=P();J(q)?q.then((L)=>D(L)).catch(O):D(q)},()=>{if(this.stale=!0,this.memo)y(this.sinks)});if(this.error)throw this.error;return this.value}}var j,w=(P)=>{if(j)P.add(j)},y=(P)=>P.forEach((I)=>I()),z=(P,I)=>{let O=j;j=I,P(),j=O};class k{P;sinks=new Set;constructor(P){this.value=P}static of(P){return new k(P)}static isState=(P)=>P instanceof k;get(){return w(this.sinks),this.value}set(P){let I=T(P)?P(this.value):P;if(!Object.is(this.value,I))this.value=I,y(this.sinks)}}var K=(P)=>{let I=()=>z(()=>{try{let O=P();if(O&&T(O))setTimeout(()=>O(),0)}catch(O){console.error(O)}},I);I()};export{K as effect,k as State,U as Computed};
