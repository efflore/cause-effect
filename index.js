var Q=(y)=>typeof y==="function",Y=(y)=>Q(y)&&/^async\s+/.test(y.toString()),q=(y)=>(x)=>x instanceof y,z=q(Error),C=q(Promise);var D="Computed",A=(y,x)=>{x=x??Y(y);let B=new Set,K,L=null,j=!0,P=()=>{if(j=!0,x)H(B)},R=()=>{try{return y(K)}catch(k){return z(k)?k:new Error(`Error during reactive computation: ${k}`)}},S=(k)=>{j=!1,K=k,L=null},M=(k)=>{j=!0,L=k},N=(k)=>z(k)?M(k):S(k),V={[Symbol.toStringTag]:D,get:()=>{if(G(B),!x||j)I(()=>{let k=R();C(k)?k.then(N).catch(M):N(k)},P);if(z(L))throw L;return K},map:(k)=>A(()=>k(V.get()))};return V},W=(y)=>!!y&&typeof y==="object"&&y[Symbol.toStringTag]===D;var F,X=!1,Z=new Set,U=(y)=>$(y)||W(y),G=(y)=>{if(F)y.add(F)},H=(y)=>y.forEach((x)=>X?Z.add(x):x()),I=(y,x)=>{let B=F;F=x,y(),F=B},T=(y)=>{X=!0,y(),X=!1,Z.forEach((x)=>x()),Z.clear()};var O=Symbol();class J{y;watchers=new Set;constructor(y){this.value=y}get(){return G(this.watchers),this.value}set(y){if(O!==y){let x=Q(y)?y(this.value):y;if(Object.is(this.value,x))return;this.value=x}if(H(this.watchers),O===y)this.watchers.clear()}map(y){return A(()=>y(this.get()))}}var g=(y)=>new J(y),$=q(J);var p=(y)=>{let x=()=>I(()=>{try{y()}catch(B){console.error(B)}},x);x()};export{g as state,$ as isState,U as isSignal,W as isComputed,p as effect,A as computed,T as batch,J as State};
