var N=(y)=>typeof y==="function",Y=(y)=>N(y)&&/^async\s+/.test(y.toString()),q=(y)=>(x)=>x instanceof y,z=q(Error),C=q(Promise);var D="Computed",A=(y,x)=>{x=x??Y(y);let B=new Set,K,L=null,j=!0,O=()=>{if(j=!0,x)H(B)},S=()=>{try{return y(K)}catch(k){return z(k)?k:new Error(`Error during reactive computation: ${k}`)}},P=(k)=>{j=!1,K=k,L=null},$=(k)=>{j=!0,L=k},M=(k)=>z(k)?$(k):P(k),V={[Symbol.toStringTag]:D,get:()=>{if(G(B),!x||j)I(()=>{let k=S();C(k)?k.then(M).catch($):M(k)},O);if(z(L))throw L;return K},map:(k)=>A(()=>k(V.get()))};return V},Q=(y)=>!!y&&typeof y==="object"&&y[Symbol.toStringTag]===D;var F,W=!1,X=new Set,R=(y)=>Z(y)||Q(y),G=(y)=>{if(F)y.add(F)},H=(y)=>y.forEach((x)=>W?X.add(x):x()),I=(y,x)=>{let B=F;F=x,y(),F=B},U=(y)=>{W=!0,y(),W=!1,X.forEach((x)=>x()),X.clear()};class J{y;watchers=new Set;constructor(y){this.value=y}get(){return G(this.watchers),this.value}set(y){if(y!==null){let x=N(y)?y(this.value):y;if(Object.is(this.value,x))return;this.value=x}if(H(this.watchers),y===null)this.watchers.clear()}map(y){return A(()=>y(this.get()))}}var T=(y)=>new J(y),Z=q(J);var E=(y)=>{let x=()=>I(()=>{try{y()}catch(B){console.error(B)}},x);x()};export{T as state,Z as isState,R as isSignal,Q as isComputed,E as effect,A as computed,U as batch,J as State};
