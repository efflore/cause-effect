var V=(z)=>typeof z==="function",U=(z)=>z!=null,j=(z)=>typeof z==="object"&&U(z),Y=(z,J)=>j(z)&&z[Symbol.toStringTag]===J,b=(z)=>Y(z,"Ok"),L=(z)=>Y(z,"Nil"),S=(z)=>Y(z,"Err"),D=(z)=>b(z)||L(z),p=(z)=>b(z)||L(z)||S(z),R=(z)=>S(z)?z:q(z),_=(z)=>W(z instanceof Error?z:new Error(String(z))),B=(z)=>({[Symbol.toStringTag]:"Ok",value:z,map:(J)=>B(J(z)),chain:(J)=>J(z),filter:(J)=>J(z)?B(z):$(),guard:(J)=>J(z)?B(z):$(),or:()=>B(z),catch:()=>B(z),match:(J)=>V(J.Ok)?J.Ok(z):B(z),get:()=>z}),$=()=>({[Symbol.toStringTag]:"Nil",map:$,chain:$,filter:$,guard:$,or:(z)=>q(z()),catch:$,match:(z)=>V(z.Nil)?z.Nil():$(),get:()=>{return}}),W=(z)=>({[Symbol.toStringTag]:"Err",error:z,map:()=>W(z),chain:()=>W(z),filter:$,guard:$,or:(J)=>q(J()),catch:(J)=>J(z),match:(J)=>V(J.Err)?J.Err(z):_(z),get:()=>{throw z}}),q=(z)=>!U(z)?$():D(z)?z:B(z),F=(z)=>{try{let J=z();return R(J)}catch(J){return _(J)}},N=async(z,J=0,K=1000)=>{let Z=async(H,I)=>{return Promise.resolve(z()).then((A)=>R(A)).catch(async(A)=>{if(H<1)return _(A);return await new Promise((Q)=>setTimeout(Q,I)),Z(H-1,I*2)})};return await Z(J,K)};async function o(...z){let J=V(z[0])?$():q(z.shift());for(let K of z){if(S(J))break;if(!V(K))return W(new TypeError("Expected a function in flow"));J=await N(()=>K(J))}return J}var h=process.env.DEV_MODE==="true",k="debug",c="info",T="warn",M="error",f=(z)=>typeof z==="string"&&z.trim()!=="",v=(z)=>z?`#${z}`:"",n=(z)=>z.length?`.${Array.from(z).join(".")}`:"",i=(z)=>`<${z.localName}${v(z.id)}${n(z.classList)}>`,t=(z)=>f(z)?`"${z}"`:j(z)?JSON.stringify(z):U(z)?String(z):"undefined",w=(z,J,K=k)=>{if(h||[M,T].includes(K))console[K](J,z);return z};var y=()=>{let z=new Map,J=new Map,K,Z=(X,x)=>F(X).match({Err:(C)=>W(w(C,x,M))}),H=()=>{K=null,z.forEach((X,x)=>X.forEach((C,G)=>Z(C(x),`Effect ${G} on ${x?.localName||"unknown"} failed`))),z.clear(),J.forEach((X)=>Z(X,"Cleanup failed")),J.clear()},I=()=>{if(K)cancelAnimationFrame(K);K=requestAnimationFrame(H)},A=(X)=>{if(!z.has(X))z.set(X,new Map);return z.get(X)},Q=(X)=>(x,C)=>{let G=!X.has(x);if(X.set(x,C),G)I()};return queueMicrotask(H),{enqueue:(X,x,C)=>Q(A(X))(x,C),cleanup:Q(J)}};var g="State",m="Computed",P,{enqueue:s,cleanup:u}=y(),d=(z)=>{if(P)z.add(P)},E=(z)=>z.forEach((J)=>J()),O=(z,J)=>{let K=P;P=J,F(z).match({Err:(Z)=>W(w(Z,"Error during reactive computation",M))}),P=K},l=(z)=>Y(z,g),r=(z)=>Y(z,m),xz=(z)=>l(z)||r(z),Bz=(z)=>{let J=new Set;return{[Symbol.toStringTag]:g,get(){return d(J),z},set(K){let Z=z;if(z=V(K)&&K.length?K(z):K,!Object.is(z,Z))E(J)},get targets(){return[...J]}}},Vz=(z,J=!1)=>{let K=new Set,Z,H=!0,I=()=>{if(H=!0,J)E(K)};return{[Symbol.toStringTag]:m,get(){if(d(K),!J||H)O(()=>{Z=z(),H=!U(Z)},I);return Z},get targets(){return[...K]}}},Wz=(z)=>{let J=()=>O(()=>q(z(s)).guard(V).map((K)=>u(z,K)),J);J()};export{t as valueString,Bz as state,y as scheduler,w as log,l as isState,xz as isSignal,p as isResult,b as isOk,Y as isObjectOfType,L as isNil,D as isMaybe,V as isFunction,S as isErr,j as isDefinedObject,U as isDefined,r as isComputed,N as gather,o as flow,q as ensure,i as elementName,Wz as effect,Vz as computed,F as attempt,g as TYPE_STATE,m as TYPE_COMPUTED,B as Ok,$ as Nil,T as LOG_WARN,c as LOG_INFO,M as LOG_ERROR,k as LOG_DEBUG,W as Err,h as DEV_MODE};
