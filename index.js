var L=(y)=>typeof y==="function",K=(y)=>L(y)&&/^async\s+/.test(y.toString()),M=(y)=>(x)=>x instanceof y,E=M(Error),N=M(Promise);class B{y;watchers=new Set;value;error=null;stale=!0;memo=!1;constructor(y,x){this.fn=y;this.memo=x??K(y)}static of=(y,x)=>new B(y,x);static isComputed=(y)=>y instanceof B;get(){let y=()=>{try{return this.fn()}catch(P){return E(P)?P:new Error(`Error during reactive computation: ${P}`)}},x=(P)=>{this.stale=!1,this.value=P,this.error=null},k=(P)=>{this.stale=!0,this.error=P},J=(P)=>E(P)?k(P):x(P);if(z(this.watchers),!this.memo||this.stale)D(()=>{let P=y();N(P)?P.then(J).catch(k):J(P)},()=>{if(this.stale=!0,this.memo)A(this.watchers)});if(this.error)throw this.error;return this.value}}B.prototype.map=q;var j,G=!1,H=new Set;function q(y){return B.of(()=>y(this.get()))}var z=(y)=>{if(j)y.add(j)},A=(y)=>y.forEach((x)=>G?H.add(x):x()),D=(y,x)=>{let k=j;j=x,y(),j=k},O=(y)=>{G=!0,y(),G=!1,H.forEach((x)=>x()),H.clear()};class I{y;watchers=new Set;constructor(y){this.value=y}static of(y){return new I(y)}static isState=(y)=>y instanceof I;get(){return z(this.watchers),this.value}set(y){let x=L(y)?y(this.value):y;if(Object.is(this.value,x))return;this.value=x,A(this.watchers)}}I.prototype.map=q;var Q=(y)=>{let x=()=>D(()=>{try{let k=y();if(k&&L(k))setTimeout(k)}catch(k){console.error(k)}},x);x()};export{Q as effect,O as batch,I as State,B as Computed};
