var s=(y)=>typeof y==="function",D=(y)=>s(y)&&/^async\s+/.test(y.toString()),E=(y)=>(P)=>P instanceof y,z=E(Error),G=E(Promise);class B{y;sinks=new Set;value;error=null;stale=!0;memo=!1;async=!1;constructor(y,P){this.fn=y;this.async=D(y),this.memo=P??this.async}static of(y,P){return new B(y,P)}static isComputed=(y)=>y instanceof B;get(){if(j(this.sinks),!this.memo||this.stale)w(()=>{let y=()=>{try{return this.fn()}catch(x){return z(x)?x:new Error(`Error during reactive computation: ${x}`)}},P=(x)=>{this.stale=O==null,this.value=x,this.error=null},k=(x)=>{this.stale=!0,this.error=x},A=(x)=>z(x)?k(x):P(x),O=y();G(O)?O.then((x)=>A(x)).catch(k):A(O)},()=>{if(this.stale=!0,this.memo)q(this.sinks)});if(this.error)throw this.error;return this.value}}var I,j=(y)=>{if(I)y.add(I)},q=(y)=>y.forEach((P)=>P()),w=(y,P)=>{let k=I;I=P,y(),I=k};class L{y;sinks=new Set;constructor(y){this.value=y}static of(y){return new L(y)}static isState=(y)=>y instanceof L;get(){return j(this.sinks),this.value}set(y){let P=s(y)?y(this.value):y;if(!Object.is(this.value,P))this.value=P,q(this.sinks)}}var H=(y)=>{let P=()=>w(()=>{try{let k=y();if(k&&s(k))setTimeout(()=>k(),0)}catch(k){console.error(k)}},P);P()};export{H as effect,L as State,B as Computed};
