var j=(y)=>typeof y==="function",M=(y)=>j(y)&&/^async\s+/.test(y.toString()),H=(y)=>(x)=>x instanceof y,I=H(Error),V=H(Promise);var Y="Computed",k={of:(y,x)=>{x=x??M(y);let L=new Set,X,A=null,G=!0,D=()=>{if(G=!0,x)K(L)},O=()=>{try{return y()}catch(B){return I(B)?B:new Error(`Error during reactive computation: ${B}`)}},P=(B)=>{G=!1,X=B,A=null},Z=(B)=>{G=!0,A=B},$=(B)=>I(B)?Z(B):P(B),F={[Symbol.toStringTag]:Y,get:()=>{if(J(L),!x||G)N(()=>{let B=O();V(B)?B.then($).catch(Z):$(B)},D);if(I(A))throw A;return X},map:(B)=>k.of(()=>B(F.get()))};return F},isComputed:(y)=>!!y&&typeof y==="object"&&y[Symbol.toStringTag]===Y};var q,Q=!1,W=new Set;var J=(y)=>{if(q)y.add(q)},K=(y)=>y.forEach((x)=>Q?W.add(x):x()),N=(y,x)=>{let L=q;q=x,y(),q=L},R=(y)=>{Q=!0,y(),Q=!1,W.forEach((x)=>x()),W.clear()};class z{y;watchers=new Set;constructor(y){this.value=y}static of(y){return new z(y)}static isState=H(z);get(){return J(this.watchers),this.value}set(y){let x=j(y)?y(this.value):y;if(Object.is(this.value,x))return;this.value=x,K(this.watchers)}map(y){return k.of(()=>y(this.get()))}}var U=(y)=>{let x=()=>N(()=>{try{let L=y();if(j(L))setTimeout(L)}catch(L){console.error(L)}},x);x()};export{U as effect,R as batch,z as State,k as Computed};
