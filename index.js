var Q=(y)=>typeof y==="function",C=(y)=>Q(y)&&/^async\s+/.test(y.toString()),q=(y)=>(x)=>x instanceof y,z=q(Error),D=q(Promise);var O="Computed",A=(y,x)=>{x=x??C(y);let B=new Set,K,L=null,j=!0,S=()=>{if(j=!0,x)H(B)},P=()=>{try{return y(K)}catch(k){return z(k)?k:new Error(`Error during reactive computation: ${k}`)}},R=(k)=>{j=!1,K=k,L=null},M=(k)=>{j=!0,L=k},V=(k)=>z(k)?M(k):R(k),Y={[Symbol.toStringTag]:O,get:()=>{if(G(B),!x||j)I(()=>{let k=P();D(k)?k.then(V).catch(M):V(k)},S);if(z(L))throw L;return K},map:(k)=>A(()=>k(Y.get()))};return Y},W=(y)=>!!y&&typeof y==="object"&&y[Symbol.toStringTag]===O;var F,X=!1,Z=new Set,U=(y)=>$(y)||W(y),G=(y)=>{if(F)y.add(F)},H=(y)=>y.forEach((x)=>X?Z.add(x):x()),I=(y,x)=>{let B=F;F=x,y(),F=B},T=(y)=>{X=!0,y(),X=!1,Z.forEach((x)=>x()),Z.clear()};var N=Symbol();class J{y;watchers=new Set;constructor(y){this.value=y}get(){return G(this.watchers),this.value}set(y){if(N!==y){let x=Q(y)?y(this.value):y;if(Object.is(this.value,x))return;this.value=x}if(H(this.watchers),N===y)this.watchers.clear()}map(y){return A(()=>y(this.get()))}}var g=(y)=>new J(y),$=q(J);var E=(y)=>{let x=()=>I(()=>{try{y()}catch(B){console.error(B)}},x);x()};export{g as state,$ as isState,U as isSignal,W as isComputed,E as effect,A as computed,T as batch,N as UNSET,J as State};
